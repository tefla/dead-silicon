; Instruction Decoder for Minimal CPU
; Decodes opcodes into control signals for 4 instructions
;
; Opcodes (authentic 6502):
;   0xA9 = LDA #imm (2 bytes) = 10101001
;   0x8D = STA $addr (3 bytes) = 10001101
;   0x4C = JMP $addr (3 bytes) = 01001100
;   0x02 = HLT (1 byte) = 00000010
;
; Inputs:
;   opcode:8  - Instruction opcode byte
;
; Outputs:
;   is_lda    - Opcode is LDA #imm
;   is_sta    - Opcode is STA $addr
;   is_jmp    - Opcode is JMP $addr
;   is_hlt    - Opcode is HLT
;   needs_imm - Instruction needs immediate operand (1 byte)
;   needs_addr - Instruction needs address operand (2 bytes)

module decoder(opcode:8) -> (is_lda, is_sta, is_jmp, is_hlt, needs_imm, needs_addr):
  ; We need to compare opcode with specific values
  ; XOR with target: if match, all bits will be 0
  ; Then NOR-reduce to check if all bits are 0
  
  ; Helper: check if 8-bit value is all zeros (result is 1 if all zeros)
  ; We'll use a NOR tree approach
  
  ; LDA #imm = 0xA9 = 10101001 binary
  ; opcode[0]=1, [1]=0, [2]=0, [3]=1, [4]=0, [5]=1, [6]=0, [7]=1
  lda_b0 = xor(opcode[0], 1)  ; bit 0 should be 1
  lda_b1 = xor(opcode[1], 0)  ; bit 1 should be 0
  lda_b2 = xor(opcode[2], 0)  ; bit 2 should be 0
  lda_b3 = xor(opcode[3], 1)  ; bit 3 should be 1
  lda_b4 = xor(opcode[4], 0)  ; bit 4 should be 0
  lda_b5 = xor(opcode[5], 1)  ; bit 5 should be 1
  lda_b6 = xor(opcode[6], 0)  ; bit 6 should be 0
  lda_b7 = xor(opcode[7], 1)  ; bit 7 should be 1
  ; If all XOR results are 0, we have a match
  lda_any01 = or(lda_b0, lda_b1)
  lda_any23 = or(lda_b2, lda_b3)
  lda_any45 = or(lda_b4, lda_b5)
  lda_any67 = or(lda_b6, lda_b7)
  lda_any0123 = or(lda_any01, lda_any23)
  lda_any4567 = or(lda_any45, lda_any67)
  lda_any = or(lda_any0123, lda_any4567)
  is_lda = not(lda_any)

  ; STA $addr = 0x8D = 10001101 binary
  ; opcode[0]=1, [1]=0, [2]=1, [3]=1, [4]=0, [5]=0, [6]=0, [7]=1
  sta_b0 = xor(opcode[0], 1)
  sta_b1 = xor(opcode[1], 0)
  sta_b2 = xor(opcode[2], 1)
  sta_b3 = xor(opcode[3], 1)
  sta_b4 = xor(opcode[4], 0)
  sta_b5 = xor(opcode[5], 0)
  sta_b6 = xor(opcode[6], 0)
  sta_b7 = xor(opcode[7], 1)
  sta_any01 = or(sta_b0, sta_b1)
  sta_any23 = or(sta_b2, sta_b3)
  sta_any45 = or(sta_b4, sta_b5)
  sta_any67 = or(sta_b6, sta_b7)
  sta_any0123 = or(sta_any01, sta_any23)
  sta_any4567 = or(sta_any45, sta_any67)
  sta_any = or(sta_any0123, sta_any4567)
  is_sta = not(sta_any)

  ; JMP $addr = 0x4C = 01001100 binary
  ; opcode[0]=0, [1]=0, [2]=1, [3]=1, [4]=0, [5]=0, [6]=1, [7]=0
  jmp_b0 = xor(opcode[0], 0)
  jmp_b1 = xor(opcode[1], 0)
  jmp_b2 = xor(opcode[2], 1)
  jmp_b3 = xor(opcode[3], 1)
  jmp_b4 = xor(opcode[4], 0)
  jmp_b5 = xor(opcode[5], 0)
  jmp_b6 = xor(opcode[6], 1)
  jmp_b7 = xor(opcode[7], 0)
  jmp_any01 = or(jmp_b0, jmp_b1)
  jmp_any23 = or(jmp_b2, jmp_b3)
  jmp_any45 = or(jmp_b4, jmp_b5)
  jmp_any67 = or(jmp_b6, jmp_b7)
  jmp_any0123 = or(jmp_any01, jmp_any23)
  jmp_any4567 = or(jmp_any45, jmp_any67)
  jmp_any = or(jmp_any0123, jmp_any4567)
  is_jmp = not(jmp_any)

  ; HLT = 0x02 = 00000010 binary
  ; opcode[0]=0, [1]=1, [2]=0, [3]=0, [4]=0, [5]=0, [6]=0, [7]=0
  hlt_b0 = xor(opcode[0], 0)
  hlt_b1 = xor(opcode[1], 1)
  hlt_b2 = xor(opcode[2], 0)
  hlt_b3 = xor(opcode[3], 0)
  hlt_b4 = xor(opcode[4], 0)
  hlt_b5 = xor(opcode[5], 0)
  hlt_b6 = xor(opcode[6], 0)
  hlt_b7 = xor(opcode[7], 0)
  hlt_any01 = or(hlt_b0, hlt_b1)
  hlt_any23 = or(hlt_b2, hlt_b3)
  hlt_any45 = or(hlt_b4, hlt_b5)
  hlt_any67 = or(hlt_b6, hlt_b7)
  hlt_any0123 = or(hlt_any01, hlt_any23)
  hlt_any4567 = or(hlt_any45, hlt_any67)
  hlt_any = or(hlt_any0123, hlt_any4567)
  is_hlt = not(hlt_any)

  ; needs_imm: LDA needs immediate byte
  needs_imm = is_lda

  ; needs_addr: STA and JMP need 16-bit address
  needs_addr = or(is_sta, is_jmp)
