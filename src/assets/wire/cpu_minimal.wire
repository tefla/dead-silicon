; Minimal CPU - 13 Instruction CPU with State Machine
; Implements: LDA #imm, LDX #imm, ADC #imm, SBC #imm, CMP #imm, STA $addr, STX $addr, JMP $addr, BEQ rel, BNE rel, INX, DEX, HLT
;
; State Machine:
;   STATE_FETCH_OP  (0) - Fetch opcode, increment PC
;   STATE_DECODE    (1) - Decode opcode, determine next state
;   STATE_FETCH_IMM (2) - Fetch immediate value (LDA)
;   STATE_FETCH_LO  (3) - Fetch address low byte (STA/JMP)
;   STATE_FETCH_HI  (4) - Fetch address high byte (STA/JMP)
;   STATE_EXEC_ST   (5) - Execute STA/STX (write to memory)
;   STATE_EXEC_JMP  (6) - Execute JMP (load PC)
;   STATE_HALTED    (7) - CPU halted
;
; Inputs:
;   clk       - Clock signal
;   reset     - Reset CPU
;   data_in:8 - Data from memory
;
; Outputs:
;   addr:16     - Address bus (PC or operand address)
;   data_out:8  - Data to memory (A register for STA)
;   mem_write   - Memory write enable
;   halted      - CPU is halted
;   a_out:8     - Current A register value (for debugging)
;   pc_out:16   - Current PC value (for debugging)
;   state_out:3 - Current state (for debugging)

module cpu_minimal(clk, reset, data_in:8) -> (addr:16, data_out:8, mem_write, halted, a_out:8, x_out:8, flags_out:4, pc_out:16, state_out:3):
  ; ==========================================
  ; State Register (3 bits for 8 states)
  ; ==========================================
  ; We use separate registers for each bit
  state0 = dff(next_state0, clk)
  state1 = dff(next_state1, clk)
  state2 = dff(next_state2, clk)
  state_out = concat(state2, state1, state0)
  
  ; ==========================================
  ; State Decoding
  ; ==========================================
  ns0 = not(state0)
  ns1 = not(state1)
  ns2 = not(state2)
  
  ; is_state_0 = 000 (FETCH_OP)
  is_state_0 = and(and(ns2, ns1), ns0)
  
  ; is_state_1 = 001 (DECODE)
  is_state_1 = and(and(ns2, ns1), state0)
  
  ; is_state_2 = 010 (FETCH_IMM for LDA)
  is_state_2 = and(and(ns2, state1), ns0)
  
  ; is_state_3 = 011 (FETCH_LO)
  is_state_3 = and(and(ns2, state1), state0)
  
  ; is_state_4 = 100 (FETCH_HI)
  is_state_4 = and(and(state2, ns1), ns0)
  
  ; is_state_5 = 101 (EXEC_STA)
  is_state_5 = and(and(state2, ns1), state0)
  
  ; is_state_6 = 110 (EXEC_JMP)
  is_state_6 = and(and(state2, state1), ns0)
  
  ; is_state_7 = 111 (HALTED)
  is_state_7 = and(and(state2, state1), state0)
  
  ; ==========================================
  ; Instruction Register
  ; ==========================================
  ; Latch opcode during FETCH_OP state (normal case) but NOT when skipping
  ; When skipping, load during DECODE instead (one cycle later with correct data)
  ir_load_fetch = and(is_state_0, not(skip_pc_inc))
  ir_load_decode_after_skip = and(is_state_1, skip_pc_inc)
  ir_load = or(ir_load_fetch, ir_load_decode_after_skip)
  ir = register8(data_in, ir_load, clk)
  
  ; Decode the instruction
  dec = decoder(ir)
  
  ; ==========================================
  ; Address Latch (low and high bytes)
  ; ==========================================
  ; Latch low byte during FETCH_LO
  addr_lo = register8(data_in, is_state_3, clk)
  
  ; Latch high byte during FETCH_HI
  addr_hi = register8(data_in, is_state_4, clk)

  ; ==========================================
  ; Branch Offset (for BEQ/BNE)
  ; ==========================================
  ; Latch offset byte during FETCH_IMM when instruction is BEQ or BNE
  is_branch = or(dec.is_beq, dec.is_bne)
  offset_load = and(is_state_2, is_branch)
  offset = register8(data_in, offset_load, clk)

  ; ==========================================
  ; Accumulator (A register)
  ; ==========================================
  ; Load A during FETCH_IMM when instruction is LDA, ADC, or SBC (NOT CMP)
  ; CMP sets flags like SBC but doesn't store result
  is_alu_op = or(dec.is_adc, dec.is_sbc)
  is_alu_or_cmp = or(is_alu_op, dec.is_cmp)
  a_load = and(is_state_2, or(dec.is_lda, is_alu_op))
  ; Mux between data_in (for LDA) and alu.result (for ADC/SBC)
  a_data_src = mux8(data_in, alu.result, is_alu_op)
  a_out = register8(a_data_src, a_load, clk)

  ; ==========================================
  ; X Index Register
  ; ==========================================
  ; Load X during FETCH_IMM when instruction is LDX
  ; Load X during DECODE when instruction is INX or DEX (implied addressing)
  is_inx_dex = or(dec.is_inx, dec.is_dex)
  x_load_ldx = and(is_state_2, dec.is_ldx)
  x_load_inx_dex = and(is_state_1, is_inx_dex)
  x_load = or(x_load_ldx, x_load_inx_dex)

  ; Compute X+1 and X-1 for INX/DEX
  ; INX: X + 1 (use adder8 with b=1, cin=0)
  ; DEX: X - 1 (use adder8 with b=0xFF, cin=0 which is X + 255 = X - 1 in 2's complement)
  ; Actually simpler: use adder8 with b=1/0xFF depending on instruction
  inx_addend = concat(0, 0, 0, 0, 0, 0, 0, 1)  ; 0x01
  dex_addend = concat(1, 1, 1, 1, 1, 1, 1, 1)  ; 0xFF (-1 in 2's complement)
  x_addend = mux8(inx_addend, dex_addend, dec.is_dex)
  x_inc_result = adder8(x_out, x_addend, 0)

  ; Select source for X: data_in for LDX, x_inc_result for INX/DEX
  x_data_src = mux8(data_in, x_inc_result.sum, is_inx_dex)
  x_out = register8(x_data_src, x_load, clk)

  ; ==========================================
  ; ALU and Flags
  ; ==========================================
  ; ALU always computes (used when needed)
  ; For ADC: op=000 (ADD), a=A register, b=data_in, cin=carry flag
  ; For SBC: op=001 (SUB), a=A register, b=data_in, cin=carry flag (borrow)
  ; For CMP: op=001 (SUB), a=A register, b=data_in, cin=1 (no borrow)
  ; alu_op[0] = 1 for SBC/CMP, 0 for ADC
  is_sub_op = or(dec.is_sbc, dec.is_cmp)
  alu_op = concat(0, 0, is_sub_op)  ; 000 = ADD, 001 = SUB

  ; cin_for_alu: Carry input to ALU, only updates in FETCH_OP (state 0)
  ; This ensures cin stays constant throughout multi-cycle ADC execution
  ; For CMP, always use cin=1 (no borrow, pure comparison)
  cin_update = is_state_0
  cin_next = and(cin_update, flag_c_out)
  cin_hold = and(not(cin_update), cin_for_alu_saved)
  cin_for_alu_in = or(cin_next, cin_hold)
  cin_for_alu_before_reset = dff(cin_for_alu_in, clk)
  ; Force cin=0 during reset
  cin_for_alu_saved = and(cin_for_alu_before_reset, not(reset))
  ; For CMP, override with 1; for ADC/SBC, use saved carry
  cin_for_alu = mux(cin_for_alu_saved, 1, dec.is_cmp)

  alu = alu8(a_out, data_in, alu_op, cin_for_alu)

  ; Flag register: Use 4 separate DFFs instead of register8 to avoid bit indexing issues
  ; flags_out[0] = C (carry), flags_out[1] = Z (zero), flags_out[2] = N (negative), flags_out[3] = V (overflow)
  ; Flags are updated during:
  ;   - DECODE (state 1) for ADC/SBC/CMP (capture flags before A register updates)
  ;   - DECODE (state 1) for INX/DEX (implied mode, single-cycle)
  ;   - FETCH_IMM (state 2) for LDA/LDX (after loading data_in)
  flags_load_alu = and(is_state_1, is_alu_or_cmp)
  flags_load_inx_dex = and(is_state_1, is_inx_dex)
  flags_load_lda_ldx = and(is_state_2, or(dec.is_lda, dec.is_ldx))
  flags_load = or(or(flags_load_alu, flags_load_inx_dex), flags_load_lda_ldx)

  ; Compute Z and N flags from data_in for LDA/LDX
  ; Z = 1 if data_in is all zeros (use NOR reduction)
  data_in_or01 = or(data_in[0], data_in[1])
  data_in_or23 = or(data_in[2], data_in[3])
  data_in_or45 = or(data_in[4], data_in[5])
  data_in_or67 = or(data_in[6], data_in[7])
  data_in_or0123 = or(data_in_or01, data_in_or23)
  data_in_or4567 = or(data_in_or45, data_in_or67)
  data_in_any = or(data_in_or0123, data_in_or4567)
  data_in_z = not(data_in_any)
  ; N = bit 7 of data_in
  data_in_n = data_in[7]

  ; Compute Z and N flags from x_inc_result for INX/DEX
  x_res_or01 = or(x_inc_result.sum[0], x_inc_result.sum[1])
  x_res_or23 = or(x_inc_result.sum[2], x_inc_result.sum[3])
  x_res_or45 = or(x_inc_result.sum[4], x_inc_result.sum[5])
  x_res_or67 = or(x_inc_result.sum[6], x_inc_result.sum[7])
  x_res_or0123 = or(x_res_or01, x_res_or23)
  x_res_or4567 = or(x_res_or45, x_res_or67)
  x_res_any = or(x_res_or0123, x_res_or4567)
  x_res_z = not(x_res_any)
  x_res_n = x_inc_result.sum[7]

  ; Select flag sources:
  ; - ALU for ADC/SBC/CMP
  ; - x_inc_result for INX/DEX
  ; - data_in for LDA/LDX
  flag_z_from_alu_or_x = mux(alu.z, x_res_z, is_inx_dex)
  flag_n_from_alu_or_x = mux(alu.n, x_res_n, is_inx_dex)
  flag_z_src = mux(flag_z_from_alu_or_x, data_in_z, flags_load_lda_ldx)
  flag_n_src = mux(flag_n_from_alu_or_x, data_in_n, flags_load_lda_ldx)

  ; Individual flag registers - load when flags_load is high, clear on reset
  ; C flag: Updated by ADC, SBC, and CMP (NOT INX/DEX)
  flags_load_c = or(flags_load_alu, 0)  ; Only ALU ops update carry
  flag_c_next = and(flags_load_c, alu.cout)
  flag_c_hold = and(not(flags_load_c), flag_c_out)
  flag_c_before_reset = or(flag_c_next, flag_c_hold)
  flag_c_in = and(flag_c_before_reset, not(reset))
  flag_c_out = dff(flag_c_in, clk)

  ; Z flag: Updated by ADC, SBC, CMP, LDA, LDX, INX, DEX
  flag_z_next = and(flags_load, flag_z_src)
  flag_z_hold = and(not(flags_load), flag_z_out)
  flag_z_before_reset = or(flag_z_next, flag_z_hold)
  flag_z_in = and(flag_z_before_reset, not(reset))
  flag_z_out = dff(flag_z_in, clk)

  ; N flag: Updated by ADC, SBC, CMP, LDA, LDX, INX, DEX
  flag_n_next = and(flags_load, flag_n_src)
  flag_n_hold = and(not(flags_load), flag_n_out)
  flag_n_before_reset = or(flag_n_next, flag_n_hold)
  flag_n_in = and(flag_n_before_reset, not(reset))
  flag_n_out = dff(flag_n_in, clk)

  ; V flag: Updated by ADC and SBC
  flag_v_next = and(flags_load_alu, alu.vout)
  flag_v_hold = and(not(flags_load_alu), flag_v_out)
  flag_v_before_reset = or(flag_v_next, flag_v_hold)
  flag_v_in = and(flag_v_before_reset, not(reset))
  flag_v_out = dff(flag_v_in, clk)

  ; Combine stored flags: [V, N, Z, C] = [bit3, bit2, bit1, bit0]
  flags_out = concat(flag_v_out, flag_n_out, flag_z_out, flag_c_out)

  ; ==========================================
  ; Program Counter
  ; ==========================================
  ; Build 16-bit address from latches (for JMP)
  jmp_target = concat(addr_hi, addr_lo)

  ; Build branch target for BEQ: (PC+1) + sign_extended_offset
  ; The +1 accounts for the pending PC increment in state 2
  ; So the offset is relative to PC+2 (address after the 2-byte BEQ instruction)
  ; Sign-extend offset[7] to make upper 8 bits
  sign_bit = offset[7]
  offset_hi = concat(sign_bit, sign_bit, sign_bit, sign_bit, sign_bit, sign_bit, sign_bit, sign_bit)
  offset_16 = concat(offset_hi, offset)

  ; Add offset to (PC + 1) by using carry-in=1
  branch_result = adder16(pc_out, offset_16, 1)
  branch_target = branch_result.sum

  ; Select between JMP target and branch target
  ; Use branch_target when BEQ or BNE, otherwise use JMP target
  pc_target = mux16(jmp_target, branch_target, is_branch)

  ; Skip PC increment flag: set when in EXEC states, cleared after DECODE
  ; The flag needs to persist through FETCH_OP and DECODE states
  ; Set when in EXEC (will be active next cycle when we enter FETCH_OP)
  set_skip = or(is_state_5, is_state_6)
  ; Clear after DECODE (when in FETCH_IMM, FETCH_LO, or HALTED), OR on reset
  clear_skip_states = or(or(is_state_2, is_state_3), is_state_7)
  clear_skip = or(clear_skip_states, reset)
  ; Keep current value if neither setting nor clearing
  keep_skip = and(not(set_skip), not(clear_skip))
  next_skip_val = or(set_skip, and(skip_pc_inc, keep_skip))
  skip_pc_inc = dff(next_skip_val, clk)

  ; PC increment during fetch states, but NOT in FETCH_OP if skip flag is set
  ; When skipping FETCH_OP increment, increment during DECODE instead (when loading IR)
  inc_in_fetch_op = and(is_state_0, not(skip_pc_inc))
  inc_in_decode_after_skip = and(is_state_1, skip_pc_inc)
  pc_inc = or(or(or(inc_in_fetch_op, inc_in_decode_after_skip), is_state_2), or(is_state_3, is_state_4))

  ; PC load during JMP execute or branch taken
  pc_load_jmp = is_state_6
  ; BEQ loads PC when in state 2, instruction is BEQ, and Z flag is set
  pc_load_beq = and(and(is_state_2, dec.is_beq), flag_z_out)
  ; BNE loads PC when in state 2, instruction is BNE, and Z flag is clear
  pc_load_bne = and(and(is_state_2, dec.is_bne), not(flag_z_out))
  pc_load = or(or(pc_load_jmp, pc_load_beq), pc_load_bne)

  pc_out = pc(clk, reset, pc_load, pc_inc, pc_target)
  
  ; ==========================================
  ; Next State Logic
  ; ==========================================
  ; Default: stay in same state (will be overridden)
  
  ; From FETCH_OP (0) -> DECODE (1): next = 001
  from_0_to_1 = is_state_0
  
  ; From DECODE (1):
  ;   if LDA/LDX/ADC/CMP/BEQ/BNE -> FETCH_IMM (2): next = 010
  ;   if STA/STX/JMP -> FETCH_LO (3): next = 011
  ;   if INX/DEX -> FETCH_OP (0): next = 000 (implied, single-cycle)
  ;   if HLT -> HALTED (7): next = 111
  needs_byte = or(dec.needs_imm, dec.needs_rel)
  from_1_to_2 = and(is_state_1, needs_byte)
  from_1_to_3 = and(is_state_1, dec.needs_addr)
  from_1_to_0 = and(is_state_1, is_inx_dex)
  from_1_to_7 = and(is_state_1, dec.is_hlt)
  
  ; From FETCH_IMM (2) -> FETCH_OP (0): next = 000
  from_2_to_0 = is_state_2
  
  ; From FETCH_LO (3) -> FETCH_HI (4): next = 100
  from_3_to_4 = is_state_3
  
  ; From FETCH_HI (4):
  ;   if STA/STX -> EXEC_ST (5): next = 101
  ;   if JMP -> EXEC_JMP (6): next = 110
  is_store = or(dec.is_sta, dec.is_stx)
  from_4_to_5 = and(is_state_4, is_store)
  from_4_to_6 = and(is_state_4, dec.is_jmp)

  ; From EXEC_ST (5) -> FETCH_OP (0): next = 000
  ; (PC already points to next instruction, skip increment via prev_was_exec)
  from_5_to_0 = is_state_5

  ; From EXEC_JMP (6) -> FETCH_OP (0): next = 000
  ; (PC now points to jump target, fetch from there)
  from_6_to_0 = is_state_6
  
  ; HALTED (7) stays at 7: next = 111
  stay_at_7 = is_state_7
  
  ; Calculate next state bits
  ; next_state0 = 1 when going to state 1, 3, 5, or 7
  goto_1 = from_0_to_1
  goto_odd = or(or(goto_1, from_1_to_3), or(from_4_to_5, stay_at_7))
  set_bit_0 = or(goto_odd, from_1_to_7)

  ; next_state1 = 1 when going to state 2, 3, 6, or 7
  goto_2_3 = or(from_1_to_2, from_1_to_3)
  goto_6_7 = or(from_4_to_6, or(from_1_to_7, stay_at_7))
  set_bit_1 = or(goto_2_3, goto_6_7)

  ; next_state2 = 1 when going to state 4, 5, 6, or 7
  goto_4 = from_3_to_4
  goto_5_6 = or(from_4_to_5, from_4_to_6)
  goto_7 = or(from_1_to_7, stay_at_7)
  set_bit_2 = or(or(goto_4, goto_5_6), goto_7)
  
  ; Apply reset (goes to state 0)
  next_state0 = and(set_bit_0, not(reset))
  next_state1 = and(set_bit_1, not(reset))
  next_state2 = and(set_bit_2, not(reset))
  
  ; ==========================================
  ; Output Logic
  ; ==========================================
  ; Address bus: PC during fetch, operand_addr during EXEC_ST
  operand_addr = concat(addr_hi, addr_lo)
  addr = mux16(pc_out, operand_addr, is_state_5)

  ; Data out: A register (for STA) or X register (for STX)
  data_out = mux8(a_out, x_out, dec.is_stx)

  ; Memory write: only during EXEC_ST
  mem_write = is_state_5

  ; Halted output
  halted = is_state_7
